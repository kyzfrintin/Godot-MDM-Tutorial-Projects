2 - transitions
    - 'room songs'
    - calling transitions in code
    - fading tracks in and out
    - intro/end segments

YT link: https://youtu.be/tiwYqy4OfyI
-----

This tutorial will introduce the more complex backbone of Godot Mixing Desk for Music - the transitions.

There are two types of transition - switching to another song (also known as horizontal re-sequencing) and adding in or removing layers of the current song (vertical re-mixing). MDM handles both of these types of transition quite easily, with handy functions for each.

Like last time, I've provided some sample music to use in this tutorial, to demonstrate these very functions. You can download the sample music here: https://www.sendspace.com/file/dpqnrd

Switching directly to another song is especially useful to mark states or areas in a game. For example, you may want one song to play inside a town, but a different song to play in a shop inside that town. Or you may want the music to change from ambient to battle, when the player enters a battle in your game. Both of these implementations may sound familiar if you've ever played a Pokémon game (or, really, one of most RPGs), and both implementations are easily supported by Mixing Desk.

To demonstrate, let's first get a simple song set up in Godot. If you use the project from the last tutorial, then you'll have the epiano ready to go. You'll just need to add another track into the Core container. The "arp" included in the sample music will work nicely. If you run the scene now, you have both the epiano and arp playing together, with some random tracks thrown in. You can keep or delete the random tracks for now, they won't be important during this tutorial. The tracks for a second song are also included in the demo music, so go ahead and set these up in their own song/core container heirarchy under MDM.

*Don't forget to include the properties of the song in the song node!*

Now, we need something to trigger these two songs to fade in or out. Some buttons will be fine for now - create a button for the song itself, and two buttons to represent the tracks in the song, and connect their signals to your main script. You'll next need to do the same for the second song, and its two tracks. Once all that's done, all you'll need to do is, under the song_pressed functions, call the "queue_bar_transition" (or queue_beat_transition, whichever you like) function from MDM, and pass through the name or index of the song to change to. The song 1 button will, of course, transition to song 1 - and vice versa for song 2. Run your project now, and you'll see that, by pressing the song buttons, MDM changes perfectly musically between the songs - it waits for the current bar to finish, and carries on with the queued song as if it were written that way.

Sometimes, however, you'll want to interject a shorter (or not) segment between your source and destination tracks. For this implementation, you'll want to use the "queue_sequence" function. It's just like queueing a bar or beat transition, with the slight added complexity of passing through three variables instead of one. Firstly is an array containing the names of the two tracks you want to play in order - the transition segment first, then the target track second. Next, a string of either "beat" or "bar", to define whether to transition on the next beat, or the next bar. Lastly, a string of either "play_once", "loop" or "shuffle" to decide the play mode of the target song. 

To demonstrate this function, let's create a simple third song - let's creatively call it "test3". It'll be 1 bar long, and also at 120bpm, 4 beats per bar - you get the idea. Under its core container, add just one audiostream to play the "hats" audio track. Now, to show this off as an intro/end segment, just replace the "queue_bar_transition" function on the song 1 button with the "queue_sequence" function. For the sequence array, use ["Test3", "test"]. Choose "bar" for transition type, and "loop" for the on_end behaviour. As simply as that - you have intro and end segments! Run your scene and press the song buttons to see for yourself. The short hi hats clip is now played in between the transitions.  You can do the same with the song2 button, of course - just change the "test" name in the sequence array for "test2". This type of implementation is brilliant for when you want to add short flourishes at the start or end of an important music piece - for example, a battle track with distinctive "win" or "lose" music at the end, or a strong introduction that need not be repeated while the main music loops.

For the track button connections, you'll want to call the "toggle_fade" function from MDM. It's as easy as queueing a bar/beat transition - just pass through the name or index of the song, and then the name or index of the track to fade in/out. Note that there are quite a few different ways to fade a track, and this is just one of them. Toggle_fade is like using a dimming lightswitch - it gradually goes on or off. Toggle_mute is an instant switch on or off. Mute/unmute funcs are just the same as toggle_mute, but are absolute directins rather than a toggle. Then you have fade_in and fade_out, which are the fade versions of the last 2 funcs. Lastly there is the magical arrangement tool, which is fadeout_below_layer() and its reverse twin, fadeout_above_layer(). These functions, as the name suggests, will fade all layers above or below the selected layer. This is useful for keeping your arrangement constantly moving with the action. Say you have 10 layers, with each added layer adding intensity to the arrangement, you could use fadeout_below_layer constantly to keep the music ebbing and flowing as the game builds and lowers in intensity.

Well, there it is: the secret to transitioning both vertically and horizontally using Godot Mixing Desk. I hope this tutorial has helped you understand the trick to creating adaptive/procedural music with GMD. I'll see you next time, when we look at the more in-depth features of Mixing Desk, such as binding track volume to a game variable, concatenated tracks, and using the MDM signals to influence the game, or even other instances of MDM.